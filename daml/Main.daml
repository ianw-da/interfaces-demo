module Main where

import Daml.Script
import DA.Assert
import DA.Foldable

-- See https://discuss.daml.com/t/example-of-a-daml-interface-step-by-step/5793

{-
Interface functions:
  toInterface
  fromInterface
  toInterfaceContractId
  fromInterfaceContractId
  queryInterface
-}

data ThingInterfaceView = ThingInterfaceView {}

interface IThing where
  viewtype ThingInterfaceView

-- Animal interface definition
interface IAnimal requires IThing where
  -- Interface must define a view type. This is a special method containing the fields
  -- that are common to all of our implementations of the interface.
  viewtype AnimalInterfaceView

  -- Interface methods. All templates that implement this interface must provide
  -- implementations of these methods.
  sound : Text -- <-- In practice this may be better in the view as it is a property not a method
  -- Note to assign a name we define a function here that is used
  -- in the choice below.
  assignName : Text -> IAnimal

  -- Define a choice on the interface that solely uses the view.
  -- Interface choices are implemented on the interface not on the templates.
  nonconsuming choice MakeSound : Text
    controller (view this).owner
    do
      -- Sound gets changed into sound : IAnimal -> Text
      pure $ sound this

  -- Functions can be 'fed in' to the interface choice implementation.
  choice AssignName : ContractId IAnimal
    with newName : Text
    controller (view this).owner
    do
      -- When assignName is used in a choice an extra parameter is added which has the
      -- interface type. Here we pass in 'this'.
      create (assignName this newName)

data AnimalInterfaceView = AnimalInterfaceView with
  owner : Party
  description : Text

-- Template definition of a Cat, which implements the Animal interface
template Cat
  with
    catowner : Party
    name : Text
  where
    signatory catowner

    -- How the IAnimal interface is implemented by the Cat template.
    -- This block can be here or inside the interface definition.
    interface instance IAnimal for Cat where
      -- All interface instances must implement a special view method which returns a value
      -- of the type declared by viewtype
      view = AnimalInterfaceView with
      -- The implementations of the Interface methods
        owner = catowner
        description = "I am a cat"

      sound = "Miaow!"

      assignName petName = toInterface @IAnimal $ this with name = petName

    -- IAnimal requires IThing
    interface instance IThing for Cat where
      view = ThingInterfaceView {}

-- Template definition of a Dog, which implements the Animal interface
template Dog
  with
    dogowner : Party
    name : Text
  where
    signatory dogowner
    
    interface instance IAnimal for Dog where
      view = AnimalInterfaceView with
        owner = dogowner
        description = "I am a dog"
    
      sound = "Woof!"
      -- Define the assignName function which is used in the interface choice. It has to return an IAnimal
      -- toInterface converts a template value to an interface value 
      assignName petName = toInterface @IAnimal $ this with name = petName

    -- IAnimal requires IThing
    interface instance IThing for Dog where
      view = ThingInterfaceView {}

-- Testing script
setup : Script ()
setup = script do
-- Party setup
  alice <- allocatePartyWithHint "Alice" (PartyIdHint "Alice")

  -- Create a cat contract
  catId <- submit alice do
    createCmd Cat with catowner = alice, name = ""
  debug catId

  -- Create a dog contract
  dogId <- submit alice do
    createCmd Dog with dogowner = alice, name = ""

  -- Get the Animal interface contract Ids for each
  -- toInterfaceContractId converts a template contract id into an interface contract id
  -- toInterfaceContractId : ContractId Cat -> ContractId Animal
  let animal1Id = toInterfaceContractId @IAnimal catId
  let animal2Id = toInterfaceContractId @IAnimal dogId

  -- Get an IAnimal interface (as opposed to a ContractId IAnimal) for the dog
  Some dog <- queryContractId alice dogId
  let dogAsIAnimal = toInterface @IAnimal dog
  -- Go back the other way
  let Some d = fromInterface @Dog dogAsIAnimal

  -- Change an interface contract id into a contract id of a different interface
  let thing1Id = coerceInterfaceContractId @IThing animal1Id
  -- Go back the other way
  let d = coerceInterfaceContractId @IAnimal thing1Id


  -- Although the types are different the ids are the same
  debug catId
  debug animal1Id

  -- Get them to make their sounds (using the interface)
  sound1 <- submit alice do
    exerciseCmd animal1Id MakeSound

  sound2 <- submit alice do
    exerciseCmd animal2Id MakeSound

  debug sound1
  debug sound2

  -- Give them names just using the interface
  animal1Id2 <- submit alice do
    exerciseCmd animal1Id AssignName with newName = "Fluffy"
  animal2Id2 <- submit alice do
    exerciseCmd animal2Id AssignName with newName = "Gnasher"
  debug animal1Id2

  -- New contracts have been created so ids have changed
  assertNotEq animal1Id2 animal1Id

  -- Go back to a Cat contract Id and verify it matches the original one
  -- Note this works even though this contract has now been archived
  let cat2Id = fromInterfaceContractId @Cat animal1Id
  catId === cat2Id

  -- Here is one way to get the new cat contract
  let cat3Id = fromInterfaceContractId @Cat animal1Id2
  Some a <- queryContractId @Cat alice cat3Id
  debug a

  -- Query all instances of IAnimal on the ledger
  items <- queryInterface @IAnimal alice
  forA_ items
   (\(ia, Some iv) -> do
     let lineItem = show iv.owner <> " " <> iv.description
     debug lineItem)

  pure ()